<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreezeSense - Commercial & Residential Ice Machine Monitoring</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%230ea5e9'/%3E%3Cpath d='M50 20 L30 35 L50 50 L70 35 Z' fill='white'/%3E%3Cpath d='M50 40 L30 55 L50 70 L70 55 Z' fill='%23e0f2fe'/%3E%3Cpath d='M50 60 L30 75 L50 90 L70 75 Z' fill='white'/%3E%3C/svg%3E" />
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js"></script>
    <script src="js/firebase.js"></script>
    <!-- Other scripts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Add Date Adapter for Chart.js Time Scale -->
    <script src="https://cdn.jsdelivr.net/npm/date-fns@^2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@^2"></script>
    <!-- End Date Adapter -->
    <script src="/components/recommendations.js"></script>
    <script src="/components/timeSeriesGraphs.js"></script>
    <script src="/components/propertiesSection.js"></script>
    <script src="/components/deviceInformation.js"></script>
    <script src="/js/deviceCard.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="app" class="min-h-screen bg-gray-100">
        <div id="nav-placeholder"></div>
        
        <!-- Placeholders for dynamically loaded content -->
        <div id="main-content"></div>
        <div id="modals-placeholder"></div>
        <div id="footer-placeholder"></div>

    </div> <!-- Close #app -->

    <script>
        // Declare variables in outer scope
        let statusEl;
        let errorEl;
        let errorMessageEl;
        let devicesContainer;
        let consoleOutput;
        let debugConsole;

        // Function to load HTML components
        function loadComponent(componentPath, placeholderId) {
            // Return the fetch promise
            return fetch(componentPath)
                .then(response => {
                    if (!response.ok) {
                        console.error(`Failed to load ${componentPath}:`, response.status, response.statusText);
                        throw new Error(`Failed to load ${componentPath}: ${response.status}`);
                    }
                    return response.text();
                })
                .then(html => {
                    const placeholder = document.getElementById(placeholderId);
                    if (placeholder) {
                        placeholder.innerHTML = html;
                    } else {
                        console.error(`Placeholder element not found: ${placeholderId}`);
                    }
                })
                .catch(error => {
                    console.error(`Error loading ${componentPath}:`, error);
                    // Display error in a user-friendly way if possible
                    showError(`Failed to load essential component: ${componentPath}. Please refresh.`);
                    // Rethrow the error so Promise.all catches it
                    throw error; 
                });
        }

        // Single Load Handler
        window.onload = () => {
            // Define API_URL based on hostname *before* loading components or fetching data
            const hostname = window.location.hostname;
            let API_URL;

            if (hostname === 'localhost') {
                API_URL = 'http://localhost:3000'; // Local development
            } else if (hostname === 'web-staging-c951.up.railway.app') {
                API_URL = 'https://web-staging-c951.up.railway.app'; // Staging API
            } else {
                API_URL = 'https://freezesense.up.railway.app'; // Production API (Default)
            }
            // Assign to window object to make it globally accessible *after* this point
            window.API_URL = API_URL;
            console.log("API_URL set to:", window.API_URL); // Add log for verification

            Promise.all([
                loadComponent('/components/navigation.html', 'nav-placeholder'),
                loadComponent('/components/main-content.html', 'main-content'),
                loadComponent('/components/modals.html', 'modals-placeholder'),
                loadComponent('/components/footer.html', 'footer-placeholder')
            ]).then(() => {
                console.log("Essential components loaded.");

                // Assign element variables now that components are loaded
                statusEl = document.getElementById('status');
                errorEl = document.getElementById('error');
                errorMessageEl = document.getElementById('error-message');
                devicesContainer = document.getElementById('devices');
                consoleOutput = document.getElementById('console-output');
                debugConsole = document.getElementById('debug-console');

                // Now that components are loaded, perform actions dependent on them
                addRefreshButton(); // Assuming this depends on nav or main content
                fetchDevices(); // Initial fetch depends on nav potentially (lastUpdateTime)

                // Corrected Modal Check (run AFTER modals are loaded)
                setTimeout(() => { // Use setTimeout to ensure DOM has rendered
                    const requiredModals = ['faq-modal', 'disclaimer-modal', 'contact-modal'];
                    const missingModals = requiredModals.filter(id => !document.getElementById(id));
                    
                    if (missingModals.length > 0) {
                        console.error('Missing modals after component load:', missingModals);
                        // Optional: Attempt re-injection using modals-placeholder
                        missingModals.forEach(modalId => {
                             // Simplified re-injection logic - might need refinement
                             if (document.getElementById('modals-placeholder')) {
                                 console.warn(`Attempting to handle missing modal: ${modalId}`);
                                 // Basic idea: fetch modals.html again and append the specific missing modal
                                 // This is complex and might be better handled by ensuring loadComponent works reliably
                             } else {
                                 console.error("Cannot re-inject modal, placeholder 'modals-placeholder' not found.")
                             }
                        });
                    } else {
                        console.log('All required modals verified after component load');
                    }
                }, 100); // Short delay

                // Set up the refresh interval (can start after initial load)
                const interval = setInterval(fetchDevices, 21600000); // 6 hours

                // Cleanup interval when page is unloaded
                window.addEventListener('unload', () => {
                    clearInterval(interval);
                });

            }).catch(error => {
                console.error("Failed to load one or more essential components:", error);
                // Display a generic error message since showError might rely on loaded components
                const errorDiv = document.getElementById('error');
                const errorMsgSpan = document.getElementById('error-message');
                if(errorDiv && errorMsgSpan) {
                    errorMsgSpan.textContent = 'Failed to load page components. Please refresh.';
                    errorDiv.classList.remove('hidden');
                }
            });
        };

        // Debug Console Functions
        function toggleConsole() {
            debugConsole.classList.toggle('hidden');
        }

        function clearConsole() {
            consoleOutput.innerHTML = '';
        }

        function logToConsole(data, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type === 'error' ? 'text-red-400' : 
                             type === 'warning' ? 'text-yellow-400' : 
                             'text-green-400';
            
            const logEntry = document.createElement('div');
            logEntry.className = colorClass;
            logEntry.innerHTML = `[${timestamp}] ${typeof data === 'object' ? JSON.stringify(data, null, 2) : data}`;
            
            consoleOutput.appendChild(logEntry);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        function showLoading() {
            statusEl.classList.remove('hidden');
            errorEl.classList.add('hidden');
            devicesContainer.innerHTML = '';
        }

        function showError(message) {
            statusEl.classList.add('hidden');
            errorEl.classList.remove('hidden');
            errorMessageEl.textContent = message;
            logToConsole(message, 'error');
        }

        function hideLoading() {
            statusEl.classList.add('hidden');
        }

        async function checkServerHealth() {
            try {
                const response = await fetch(`${API_URL}/health`);
                if (!response.ok) throw new Error('Server health check failed');
                return true;
            } catch (error) {
                console.error('Server health check failed:', error);
                logToConsole('Server health check failed: ' + error.message, 'error');
                return false;
            }
        }

        function updateLastUpdateTime() {
            const now = new Date();
            document.getElementById('lastUpdateTime').textContent = now.toLocaleTimeString();
        }

        async function fetchDevices() {
            showLoading();
            
            try {
                // First check if server is healthy
                const isHealthy = await checkServerHealth();
                if (!isHealthy) {
                    throw new Error('Server is not responding. Please make sure the server is running.');
                }

                const response = await fetch(`${API_URL}/api/devices`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const devices = await response.json();
                
                if (devices.error) {
                    throw new Error(devices.message || devices.error);
                }
                
                // Sort devices by name
                devices.sort((a, b) => {
                    // Extract numbers from device names (assuming format like "001", "002", etc.)
                    const aNum = parseInt(a.name.replace(/\D/g, '')) || 0;
                    const bNum = parseInt(b.name.replace(/\D/g, '')) || 0;
                    return aNum - bNum;
                });
                
                // Store the sorted devices data for modal use
                window.lastDevicesData = devices;
                
                // Update last update time
                updateLastUpdateTime();
                
                // Log raw device data to console
                logToConsole('Received device data (sorted):');
                logToConsole(devices);
                
                displayDevices(devices);
                hideLoading();
            } catch (error) {
                console.error('Error fetching devices:', error);
                showError(error.message || 'Failed to fetch devices. Please try again later.');
            }
        }

        function formatPropertyValue(property) {
            if (property.last_value === undefined || property.last_value === null) {
                return 'N/A';
            }

            switch(property.type) {
                case 'BOOL':
                    return property.last_value ? 'True' : 'False';
                case 'FLOAT':
                    if (property.name === 'sensorplacement') {
                        const percentage = property.last_value * 100;
                        return `${percentage}%`;
                    }
                    if (property.name.toLowerCase().includes('temp')) {
                        const fahrenheit = celsiusToFahrenheit(property.last_value);
                        return `${fahrenheit.toFixed(1)}°F`;
                    }
                    if (property.name.toLowerCase().includes('flow')) {
                        return `${Number(property.last_value).toFixed(2)} L/min`;
                    }
                    return Number(property.last_value).toFixed(2);
                case 'INT':
                    return property.last_value.toString();
                case 'STRING':
                    return property.last_value;
                default:
                    return property.last_value;
            }
        }

        function getPropertyInputType(property) {
            switch(property.type) {
                case 'BOOL':
                    return 'checkbox';
                case 'INT':
                case 'FLOAT':
                    return 'number';
                default:
                    return 'text';
            }
        }

        function getPropertyStep(property) {
            switch(property.type) {
                case 'FLOAT':
                    return '0.01';
                case 'INT':
                    return '1';
                default:
                    return 'any';
            }
        }

        function fahrenheitToCelsius(fahrenheit) {
            return (fahrenheit - 32) * 5/9;
        }

        async function updatePropertyValue(deviceId, property) {
            try {
                if (!deviceId || !property) {
                    throw new Error('Device ID and Property are required');
                }

                // Log the update attempt with all details
                logToConsole({
                    message: 'Attempting to update property',
                    deviceId: deviceId,
                    propertyName: property.name,
                    currentValue: property.last_value,
                    newValue: property.new_value,
                    propertyType: property.type
                }, 'info');

                // Format the value based on type
                let formattedValue;
                switch(property.type) {
                    case 'INT':
                        formattedValue = parseInt(property.new_value);
                        if (isNaN(formattedValue)) {
                            throw new Error('Invalid integer value');
                        }
                        break;
                    case 'FLOAT':
                        // Convert Fahrenheit to Celsius if this is a temperature property
                        if (property.name.toLowerCase().includes('temp')) {
                            formattedValue = fahrenheitToCelsius(parseFloat(property.new_value));
                        } else {
                            formattedValue = parseFloat(property.new_value);
                        }
                        if (isNaN(formattedValue)) {
                            throw new Error('Invalid float value');
                        }
                        break;
                    case 'BOOL':
                        // Convert to actual boolean instead of string
                        formattedValue = property.new_value === true || property.new_value === 'true';
                        break;
                    case 'CHARSTRING':
                    case 'STATUS':
                        formattedValue = String(property.new_value).trim();
                        if (!formattedValue) {
                            throw new Error('Value cannot be empty');
                        }
                        break;
                    default:
                        formattedValue = property.new_value;
                }

                // Using V2 API endpoint format and structure
                const apiUrl = `${API_URL}/api/iot/v2/devices/${deviceId}/properties`;

                // Construct payload exactly as per Arduino V2 API docs
                const requestBody = {
                    propertiesValues: {
                        input: true,
                        properties: [{
                            name: property.name,
                            type: property.type,
                            value: formattedValue // Send raw value without converting to string
                        }]
                    }
                };

                logToConsole({
                    message: 'Sending update request',
                    url: apiUrl,
                    body: requestBody
                }, 'info');

                const response = await fetch(apiUrl, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'X-Organization': property.organization_id || ''  // Add organization ID if available
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    throw new Error(errorData?.error || `HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                logToConsole({
                    message: 'Update successful',
                    deviceId: deviceId,
                    propertyName: property.name,
                    response: result
                }, 'info');

                // Refresh the devices list to show the new value
                await fetchDevices();
                setTimeout(() => {
                    location.reload(true);
                }, 3000); // Wait 3 seconds before reloading
                
            } catch (error) {
                logToConsole({
                    message: 'Error updating property',
                    error: error.message,
                    deviceId: deviceId,
                    propertyName: property?.name
                }, 'error');
                showError(`Failed to update property: ${error.message}`);
            }
        }

       

        // Enter key handler - triggers the update button click
        function handlePropertyInputKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = event.target;
                const button = input.nextElementSibling;
                if (button) {
                    button.click();
                }
            }
        }

        // Remove all other handlers to avoid conflicts
        function handlePropertyUpdate(event) {
            if (event.key === 'Enter') {
                handlePropertyInputKeydown(event);
            }
        }

        function handlePropertyInputChange(event) {
            const input = event.target;
            if (input.type === 'checkbox') {
                const button = input.nextElementSibling;
                if (button) {
                    button.click();
                }
            }
        }

        // Remove keyboard shortcut for auto-commit since it's no longer needed
        document.removeEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
                autoCommitChanges();
            }
        });

        // Add date validation function
        function isValidMaintenanceDate(dateStr) {
            // Check if the format is correct (MM/DD/YYYY)
            const regex = /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/[0-9]{4}$/;
            if (!regex.test(dateStr)) return false;

            // Parse the date
            const [month, day, year] = dateStr.split('/').map(num => parseInt(num));
            const date = new Date(year, month - 1, day); // month is 0-based in JS

            // Check if the date is valid and not in the future
            const now = new Date();
            now.setHours(23, 59, 59, 999); // End of today
            if (date > now) return false;

            // Check if the parsed date matches the input
            // This catches invalid dates like 02/31/2024
            return date.getMonth() === month - 1 && 
                   date.getDate() === day && 
                   date.getFullYear() === year;
        }

        // Modify the property update handling
        function handlePropertyInputKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const input = event.target;
                const button = input.nextElementSibling;
                if (button) {
                    button.click(); // Use native click instead of dispatching event
                }
            }
        }

        function handlePropertyInputChange(event) {
            const input = event.target;
            const deviceId = input.dataset.deviceId;
            
            try {
                const property = JSON.parse(input.dataset.property);
                property.new_value = input.type === 'checkbox' ? input.checked : input.value;
                
                if (!deviceId) {
                    throw new Error('Device ID is missing');
                }
                
                updatePropertyValue(deviceId, property);
            } catch (error) {
                logToConsole(`Error handling property input: ${error.message}`, 'error');
                showError(`Failed to handle property input: ${error.message}`);
            }
        }

        function getPropertyBgColor(propertyName) {
            // Return consistent blue background for all properties
            return 'bg-blue-50';
        }

        function getPropertyTextColor(propertyName) {
            // Return consistent blue text for all properties
            return 'text-blue-800';
        }

        function formatTemperature(celsius, maxThreshold = null) {
            if (celsius === undefined || celsius === null) return 'N/A';
            const fahrenheit = celsiusToFahrenheit(celsius);
            const value = `${fahrenheit.toFixed(1)}°F`;
            // Remove conditional span wrapper
            return value;
        }

        function getTemperatureCardClass(temp, maxThreshold) {
            if (temp === undefined || temp === null || maxThreshold === undefined || maxThreshold === null) {
                // Return empty string if no data
                return '';
            }
            // Return only the border class if critical, otherwise empty string
            return temp >= maxThreshold ? 'border-red-500 border-2' : '';
        }


        // Store timers for cleanup
        let timeSinceFlowTimers = [];

        function clearTimeSinceFlowTimers() {
            timeSinceFlowTimers.forEach(timer => clearInterval(timer));
            timeSinceFlowTimers = [];
        }

        function getFlowCardClass(timeSinceFlowHours, criticalTime) {
            if (timeSinceFlowHours === null || criticalTime === undefined || criticalTime === null) {
                // Return empty string if no data or threshold
                return '';
            }
            // Return only the border class if critical, otherwise empty string
            return parseFloat(timeSinceFlowHours) >= parseFloat(criticalTime) ? 'border-red-500 border-2' : '';
        }

        function updateTimeSinceFlow(element, startTime) {
            if (!startTime) {
                element.textContent = 'N/A';
                return null;
            }

            const criticalTime = parseFloat(element.dataset.criticalTime);
            const cardElement = element.closest('.property-card');
            const deviceId = element.dataset.deviceId;

            // Log initial state only once when timer starts
            logToConsole(`Initializing flow timer for device ${deviceId}:`, {
                startTime,
                criticalTime,
                currentTime: new Date().toISOString()
            });

            let lastCriticalState = false; // Track previous critical state

            const update = () => {
                const timeSinceFlowMs = new Date() - new Date(startTime);
                const timeSinceFlowHours = timeSinceFlowMs / (1000 * 60 * 60);
                element.textContent = formatTimeDuration(timeSinceFlowMs);

                // Get the conditional border class
                const borderClass = getFlowCardClass(timeSinceFlowHours, criticalTime);
                const isCriticalNow = !!borderClass; // Check if borderClass is not empty

                // Define the classes to add/remove for critical state text/icon color
                const criticalTextClasses = ['[&_p]:text-red-700', '[&_svg]:text-red-600', '[&_div]:text-red-600'];

                // Add or remove border and text color classes based on critical state
                if (isCriticalNow) {
                    cardElement.classList.add('border-red-500', 'border-2');
                    cardElement.classList.add(...criticalTextClasses);
                    // REMOVED: Old logic targeting only the main value element
                    // element.classList.remove('text-blue-900');
                    // element.classList.add('text-red-700');
                } else {
                    cardElement.classList.remove('border-red-500', 'border-2');
                    cardElement.classList.remove(...criticalTextClasses);
                    // REMOVED: Old logic targeting only the main value element
                    // element.classList.remove('text-red-700');
                    // element.classList.add('text-blue-900');
                }

                // Only log when critical state changes
                if (isCriticalNow !== lastCriticalState) {
                    lastCriticalState = isCriticalNow;
                    if (isCriticalNow) {
                        logToConsole(`Flow state changed to critical for device ${deviceId}:`, {
                            timeSinceFlowHours,
                            criticalTime,
                            lastUpdate: startTime
                        });
                    }
                }
            };

            update(); // Initial update
            const timer = setInterval(update, 1000); // Update every second
            timeSinceFlowTimers.push(timer);
            return timer;
        }

        // Add cooldown tracking for warning and critical updates
        const lastStatusUpdate = {
            warning: {},
            critical: {}
        };

        const COOLDOWN_TIME = 5000; // 5 seconds in milliseconds

        function canUpdateStatus(deviceId, statusType) {
            const lastUpdate = lastStatusUpdate[statusType][deviceId];
            if (!lastUpdate) return true;
            
            const timeSinceLastUpdate = Date.now() - lastUpdate;
            return timeSinceLastUpdate >= COOLDOWN_TIME;
        }

        function updateLastStatusTime(deviceId, statusType) {
            lastStatusUpdate[statusType][deviceId] = Date.now();
            logToConsole(`Updated ${statusType} status for device ${deviceId}. Next update allowed after ${new Date(Date.now() + COOLDOWN_TIME).toLocaleTimeString()}`);
        }

        function calculateDeviceStatus(device) {
            // Check connection status from Arduino Cloud
            const statusEvent = device.events?.find(event => event.name === 'r_status');
            const isConnected = statusEvent?.value === 'CONNECTED';
            const lastConnectedTime = statusEvent?.updated_at;

            // Find key properties
            const properties = device.thing?.properties || [];
            
            // Get current warning and critical states with normalized boolean values
            const warningProperty = properties.find(p => p.name === 'warning');
            const criticalProperty = properties.find(p => p.name === 'critical');
            
            // Helper function to normalize boolean values
            const normalizeBoolean = (value) => {
                if (value === 'true' || value === true) return true;
                if (value === 'false' || value === false) return false;
                return false; // default value
            };
            
            // Normalize current values
            const currentWarning = normalizeBoolean(warningProperty?.last_value);
            const currentCritical = normalizeBoolean(criticalProperty?.last_value);

            // Get cloud temperature
            const cloudTemp = properties.find(p => 
                p.name === 'cloudtemp'
            )?.last_value;

            // Get temperature threshold max
            const tempThresholdMax = properties.find(p => 
                p.name === 'tempThresholdMax'
            )?.last_value;

            // Get flow related properties
            const cloudFlowRate = properties.find(p => 
                p.name === 'cloudflowrate'
            );

            const noFlowCriticalTime = properties.find(p => 
                p.name === 'noFlowCriticalTime'
            )?.last_value;

            // Calculate time since last flow
            const flowLastUpdate = cloudFlowRate?.value_updated_at;
            const timeSinceFlowMs = flowLastUpdate ? new Date() - new Date(flowLastUpdate) : null;
            const timeSinceFlowHours = timeSinceFlowMs ? timeSinceFlowMs / (1000 * 60 * 60) : null;

            // Status conditions
            const isTemperatureBad = cloudTemp !== undefined && cloudTemp > tempThresholdMax;
            const isFlowBad = timeSinceFlowHours !== null && !isNaN(noFlowCriticalTime) && timeSinceFlowHours >= noFlowCriticalTime;

            // Great: Device must be connected AND temperature is below threshold AND flow time is below critical threshold
            const isGreat = isConnected && !isTemperatureBad && !isFlowBad;

            // Warning: Device must be connected AND exactly one condition is bad (temp XOR flow)
            const isWarning = isConnected && ((isTemperatureBad || isFlowBad) && !(isTemperatureBad && isFlowBad));

            // Critical: Device is disconnected OR both temperature and flow are bad
            const isCritical = !isConnected || (isTemperatureBad && isFlowBad);

            // Compare normalized boolean values
            const shouldUpdateWarning = currentWarning !== isWarning;
            const shouldUpdateCritical = currentCritical !== isCritical;

            // Debug logging
            if (shouldUpdateWarning || shouldUpdateCritical) {
                logToConsole('Status update check:', {
                    deviceId: device.id,
                    currentWarning,
                    isWarning,
                    currentCritical,
                    isCritical,
                    shouldUpdateWarning,
                    shouldUpdateCritical,
                    temperature: cloudTemp,
                    tempThreshold: tempThresholdMax,
                    timeSinceFlowHours,
                    noFlowCriticalTime
                });
            }

            // Only update if the values are actually different and cooldown period has elapsed
            if (shouldUpdateWarning && canUpdateStatus(device.id, 'warning')) {
                logToConsole(`Auto-updating warning status for device ${device.id} from ${currentWarning} to ${isWarning}`);
                handleManualStatusUpdate(device.id, 'warning', isWarning);
            }

            if (shouldUpdateCritical && canUpdateStatus(device.id, 'critical')) {
                logToConsole(`Auto-updating critical status for device ${device.id} from ${currentCritical} to ${isCritical}`);
                handleManualStatusUpdate(device.id, 'critical', isCritical);
            }

            // Get sensor placement
            const sensorPlacement = properties.find(p => 
                p.name === 'sensorplacement'
            )?.last_value;

            // Calculate ice level based on temperature and sensor placement
            // const tempF = cloudTemp !== undefined ? celsiusToFahrenheit(cloudTemp) : undefined; // No longer needed for this calculation
            // const isIceAboveSensor = tempF !== undefined && tempF <= 34; // OLD LOGIC - Incorrectly used hardcoded 34F
            const isIceAboveSensor = cloudTemp !== undefined && tempThresholdMax !== undefined && cloudTemp <= tempThresholdMax; // NEW LOGIC - Use dynamic threshold

            // If temperature is ≤ threshold, ice is above the sensor placement
            // If temperature is > threshold, ice is below the sensor placement
            const iceLevel = {
                isAboveSensor: isIceAboveSensor,
                sensorPlacement: sensorPlacement
            };

            return {
                isConnected,
                isGreat,
                isWarning,
                isCritical,
                cloudTemp,
                tempThresholdMax,
                cloudFlowRate: cloudFlowRate?.last_value,
                timeSinceFlowMs,
                timeSinceFlowHours,
                noFlowCriticalTime,
                flowLastUpdate,
                lastConnectedTime,
                iceLevel,
                sensorPlacement
            };
        }

        // Update the ice level display in the device card
        function getIceLevelText(status) {
            if (status.sensorPlacement === undefined || status.sensorPlacement === null) {
                return 'Sensor placement not set';
            }
            
            const placement = (status.sensorPlacement * 100).toFixed(0);
            if (status.cloudTemp === undefined || status.tempThresholdMax === undefined) {
                return 'Temperature data unavailable';
            }

            // Compare with threshold temperature
            return status.cloudTemp <= status.tempThresholdMax ? 
                `More than ${placement}% full` : 
                `Less than ${placement}% full`;
        }

        // Add this sorting function before displayDevices
        function sortProperties(properties) {
            // Define priority properties
            const priorityProps = ['cloudtemp', 'cloudflowrate'];
            
            return [...properties].sort((a, b) => {
                // Get indices in priority array (-1 if not found)
                const aIndex = priorityProps.indexOf(a.name);
                const bIndex = priorityProps.indexOf(b.name);
                
                // If both are priority properties, sort by priority array order
                if (aIndex !== -1 && bIndex !== -1) {
                    return aIndex - bIndex;
                }
                
                // If only a is priority property, it goes first
                if (aIndex !== -1) return -1;
                
                // If only b is priority property, it goes first
                if (bIndex !== -1) return 1;
                
                // For non-priority properties, maintain original order
                return 0;
            });
        }

        function displayDevices(devices) {
            // Clear existing timers before updating display
            clearTimeSinceFlowTimers();

            // Update device counts
            const activeDevices = devices.length;
            const deviceStatuses = devices.map(device => calculateDeviceStatus(device));
            const connectedDevices = deviceStatuses.filter(status => status.isConnected).length;
            const warningDevices = deviceStatuses.filter(status => status.isWarning).length;
            const criticalDevices = deviceStatuses.filter(status => status.isCritical).length;
            
            // Update status counts
            document.getElementById('totalDevicesCount').textContent = activeDevices;
            document.getElementById('connectedDevicesCount').textContent = connectedDevices;
            document.getElementById('warningDevicesCount').textContent = warningDevices;
            document.getElementById('criticalDevicesCount').textContent = criticalDevices;

            // Update disconnected badge
            const badgeElement = document.getElementById('disconnectedBadgeCount');
            if (badgeElement) {
                const disconnectedDevices = activeDevices - connectedDevices;
                if (disconnectedDevices > 0) {
                    badgeElement.textContent = disconnectedDevices;
                    badgeElement.classList.remove('hidden');
                } else {
                    badgeElement.classList.add('hidden');
                }
            }

            if (!Array.isArray(devices) || devices.length === 0) {
                devicesContainer.innerHTML = `
                    <div class="col-span-full text-center py-8">
                        <div class="max-w-sm mx-auto">
                            <svg class="w-12 h-12 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01M12 12h.01" />
                            </svg>
                            <p class="mt-4 text-gray-500 text-lg">No devices found</p>
                            <p class="mt-2 text-gray-400 text-sm">Connect a device to get started</p>
                        </div>
                    </div>
                `;
                logToConsole('No devices found', 'warning');
                return;
            }

            // Sort devices by name
            devices.sort((a, b) => {
                const aName = a.thing?.properties?.find(p => p.name === 'devicename')?.last_value || a.name;
                const bName = b.thing?.properties?.find(p => p.name === 'devicename')?.last_value || b.name;
                return aName.localeCompare(bName);
            });

            // Display devices
            devicesContainer.innerHTML = devices.map(device => {
                const status = calculateDeviceStatus(device);
                const deviceName = device.thing?.properties?.find(p => p.name === 'devicename')?.last_value || device.name || 'Unnamed Device';
                const location = device.thing?.properties?.find(p => p.name === 'location')?.last_value || 'Location not set';
                
                return `
                    <div class="bg-white rounded-lg shadow-sm border ${status.isCritical ? 'border-red-200' : status.isWarning ? 'border-yellow-200' : 'border-gray-200'} p-4">
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="text-lg font-medium text-gray-800">${deviceName}</h3>
                            <span class="px-2 py-1 text-xs font-medium rounded-full ${
                                status.isCritical ? 'bg-red-100 text-red-800' :
                                status.isWarning ? 'bg-yellow-100 text-yellow-800' :
                                status.isConnected ? 'bg-green-100 text-green-800' :
                                'bg-gray-100 text-gray-800'
                            }">
                                ${status.isCritical ? 'Critical' :
                                  status.isWarning ? 'Warning' :
                                  status.isConnected ? 'Connected' :
                                  'Disconnected'}
                            </span>
                        </div>
                        <p class="text-sm text-gray-500 mb-2">${location}</p>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-gray-600">Cloud Temp</span>
                                <span class="text-sm font-medium ${
                                    status.cloudTemp > status.tempThresholdMax ? 'text-red-600' :
                                    status.cloudTemp > status.tempThresholdMin ? 'text-yellow-600' :
                                    'text-green-600'
                                }">
                                    ${formatTemperature(status.cloudTemp)}
                                </span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-gray-600">Time Since Flow</span>
                                <span class="text-sm font-medium ${
                                    status.timeSinceFlowMs > status.noFlowCriticalTime * 3600000 ? 'text-red-600' :
                                    status.timeSinceFlowMs > status.noFlowWarningTime * 3600000 ? 'text-yellow-600' :
                                    'text-green-600'
                                }">
                                    ${formatTimeDuration(status.timeSinceFlowMs)}
                                </span>
                            </div>
                        </div>
                        <div class="mt-4 flex justify-end">
                            <button onclick="showDeviceDetails('${device.id}')" class="text-sm text-blue-600 hover:text-blue-800 font-medium">
                                View Details
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            // Log device data to console
            logToConsole('Devices displayed successfully', 'info');
        }

        function showDeviceDetails(deviceIndex) {
            const device = window.lastDevicesData[deviceIndex];
            const modal = document.getElementById('device-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const status = calculateDeviceStatus(device);

            modalTitle.textContent = device.thing?.properties?.find(p => p.name === 'devicename')?.last_value || device.name || 'Device Details';
            
            // Generate the detailed view with improved layout
            modalContent.innerHTML = `
                <div class="space-y-6">
                    <!-- Time Series Graphs Section -->
                    <div class="bg-white rounded-lg shadow-lg border border-gray-100 p-4 mb-6">
                        <div class="flex items-center space-x-2 mb-4">
                            <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                            </svg>
                            <h3 class="text-xl font-semibold text-gray-900">Time Series Data</h3>
                        </div>

                        <!-- Temperature Graph -->
                        <div class="mb-6">
                            <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-2">
                                <h4 class="text-sm font-medium text-gray-700">Temperature</h4>
                                <div class="flex flex-col md:flex-row gap-4 items-start md:items-center">
                                    <div class="flex items-center space-x-4">
                                        <label class="inline-flex items-center">
                                            <input type="checkbox" 
                                                class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500" 
                                                id="showTemperature" 
                                                checked 
                                                onchange="handleVisibilityToggle('temperature')">
                                            <span class="ml-2 text-sm text-gray-700">Show Temperature</span>
                                        </label>
                                        <label class="inline-flex items-center">
                                            <input type="checkbox" 
                                                class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500" 
                                                id="showIceLevel" 
                                                checked 
                                                onchange="handleVisibilityToggle('iceLevel')">
                                            <span class="ml-2 text-sm text-gray-700">Show Ice Level</span>
                                        </label>
                                    </div>
                                    <div class="time-range-selector" id="temperature-time-range">
                                        <button class="time-range-button" data-days="0" onclick="handleTimeRangeClick(event, 'temperature')">Today</button>
                                        <button class="time-range-button" data-days="1" onclick="handleTimeRangeClick(event, 'temperature')">Yesterday</button>
                                        <button class="time-range-button" data-days="2" onclick="handleTimeRangeClick(event, 'temperature')">2 Days Ago</button>
                                    </div>
                                </div>
                            </div>
                            <!-- Add Temperature Statistics Summary Box -->
                            <div id="temperatureStats" class="grid grid-cols-1 gap-4 mb-4 p-4 bg-gray-50 rounded-lg">
                                <!-- Info Message -->
                                <div class="col-span-full mb-2">
                                    <p class="text-xs text-gray-600 italic">
                                        Note: Statistics are only available when a single time period is selected.
                                        Multi-day selections will disable these statistics.
                                    </p>
                                </div>
                                
                                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                                    <div class="stat-box">
                                        <h5 class="text-xs font-medium text-gray-500">
                                            Daily Range
                                            <span class="ml-1 cursor-help group relative">
                                                <svg class="w-3 h-3 inline text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                                <span class="hidden group-hover:block absolute bottom-full left-0 w-48 p-2 bg-gray-800 text-xs text-white rounded shadow-lg mb-2">
                                                    Shows min-max temperature from 12:01 AM to 11:59 PM.
                                                </span>
                                            </span>
                                        </h5>
                                        <p class="text-sm font-bold text-gray-900" id="tempRange">-</p>
                                    </div>
                                    <div class="stat-box">
                                        <h5 class="text-xs font-medium text-gray-500">
                                            Daily Average
                                            <span class="ml-1 cursor-help group relative">
                                                <svg class="w-3 h-3 inline text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                                <span class="hidden group-hover:block absolute bottom-full left-0 w-48 p-2 bg-gray-800 text-xs text-white rounded shadow-lg mb-2">
                                                    Average temperature over the entire day.
                                                </span>
                                            </span>
                                        </h5>
                                        <p class="text-sm font-bold text-gray-900" id="tempAvg">-</p>
                                    </div>
                                    <div class="stat-box">
                                        <h5 class="text-xs font-medium text-gray-500">
                                            Std Deviation
                                            <span class="ml-1 cursor-help group relative">
                                                <svg class="w-3 h-3 inline text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                                <span class="hidden group-hover:block absolute bottom-full left-0 w-48 p-2 bg-gray-800 text-xs text-white rounded shadow-lg mb-2">
                                                    Measure of temperature variation throughout the day.
                                                </span>
                                            </span>
                                        </h5>
                                        <p class="text-sm font-bold text-gray-900" id="tempStdDev">-</p>
                                    </div>
                                    <div class="stat-box">
                                        <h5 class="text-xs font-medium text-gray-500">
                                            Mode
                                            <span class="ml-1 cursor-help group relative">
                                                <svg class="w-3 h-3 inline text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                                <span class="hidden group-hover:block absolute bottom-full left-0 w-48 p-2 bg-gray-800 text-xs text-white rounded shadow-lg mb-2">
                                                    Most frequent temperature value during the day.
                                                </span>
                                            </span>
                                        </h5>
                                        <p class="text-sm font-bold text-gray-900" id="tempMode">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="temperatureChart"></canvas>
                            </div>
                        </div>

                        <!-- Flow Time Graph -->
                        <div class="mb-6">
                            <div class="flex justify-between items-center mb-2">
                                <h4 class="text-sm font-medium text-gray-700">Flow Rate</h4>
                                <div class="time-range-selector" id="flow-time-range">
                                    <button class="time-range-button" data-days="0" onclick="handleTimeRangeClick(event, 'flow')">Today</button>
                                    <button class="time-range-button" data-days="1" onclick="handleTimeRangeClick(event, 'flow')">Yesterday</button>
                                    <button class="time-range-button" data-days="2" onclick="handleTimeRangeClick(event, 'flow')">2 Days Ago</button>
                                </div>
                            </div>
                            <!-- Add Flow Rate Statistics Summary Box -->
                            <div id="flowStats" class="grid grid-cols-1 gap-4 mb-4 p-4 bg-gray-50 rounded-lg">
                                <!-- Info Message -->
                                <div class="col-span-full mb-2">
                                    <p class="text-xs text-gray-600 italic">
                                        Note: Statistics are only available when a single time period is selected.
                                        Multi-day selections will disable these statistics.
                                    </p>
                                </div>
                                
                                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div class="stat-box">
                                        <h5 class="text-xs font-medium text-gray-500">
                                            Daily Range
                                            <span class="ml-1 cursor-help group relative">
                                                <svg class="w-3 h-3 inline text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                                <span class="hidden group-hover:block absolute bottom-full left-0 w-48 p-2 bg-gray-800 text-xs text-white rounded shadow-lg mb-2">
                                                    Shows minimum and maximum flow rates from 12:01 AM to 11:59 PM.
                                                </span>
                                            </span>
                                        </h5>
                                        <p class="text-sm font-bold text-gray-900" id="flowRange">-</p>
                                    </div>
                                    <div class="stat-box">
                                        <h5 class="text-xs font-medium text-gray-500">
                                            Total Flow
                                            <span class="ml-1 cursor-help group relative">
                                                <svg class="w-3 h-3 inline text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                                <span class="hidden group-hover:block absolute bottom-full left-0 w-48 p-2 bg-gray-800 text-xs text-white rounded shadow-lg mb-2">
                                                    Total volume of water flow for the selected day.
                                                </span>
                                            </span>
                                        </h5>
                                        <p class="text-sm font-bold text-gray-900" id="flowTotal">-</p>
                                    </div>
                                    <div class="stat-box">
                                        <h5 class="text-xs font-medium text-gray-500">
                                            Std Deviation
                                            <span class="ml-1 cursor-help group relative">
                                                <svg class="w-3 h-3 inline text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                                </svg>
                                                <span class="hidden group-hover:block absolute bottom-full left-0 w-48 p-2 bg-gray-800 text-xs text-white rounded shadow-lg mb-2">
                                                    Measure of flow rate variation throughout the day.
                                                </span>
                                            </span>
                                        </h5>
                                        <p class="text-sm font-bold text-gray-900" id="flowStdDev">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="flowChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Initialize the graphs
            initializeGraphs(deviceIndex);

            modal.classList.remove('hidden');
            modal.classList.add('flex');

            // Add click event listener to close modal when clicking outside
            modal.addEventListener('click', function(event) {
                // Check if the click was on the modal background (not the content)
                if (event.target === modal) {
                    hideDeviceDetails();
                }
            });
        }

        function hideDeviceDetails() {
            const modal = document.getElementById('device-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        // Standardize all property update handlers
        async function handleUpdateButtonClick(event) {
            event.preventDefault(); // Prevent any default button behavior
            const button = event.target;
            const input = button.previousElementSibling;
            const deviceId = button.dataset.deviceId;
            
            try {
                const property = JSON.parse(button.dataset.property);
                
                // Add validation for Last_Maintenance property
                if (property.name === 'Last_Maintenance') {
                    if (!isValidMaintenanceDate(input.value)) {
                        showError('Please enter a valid date in MM/DD/YYYY format. Date cannot be in the future.');
                        return;
                    }
                }
                
                // Disable input and button during update
                input.disabled = true;
                button.disabled = true;
                const originalText = button.innerHTML;
                button.innerHTML = '<span class="animate-spin">⌛</span>';
                
                property.new_value = input.value;
                
                // Log the update attempt
                logToConsole({
                    message: 'Attempting to update property via button click',
                    deviceId: deviceId,
                    propertyName: property.name,
                    currentValue: property.last_value,
                    newValue: property.new_value
                }, 'info');
                
                await updatePropertyValue(deviceId, property);
                
                // Show success toast
                showToast('Property updated successfully. Refreshing...', 'success');
                
                // Small delay to show success state
                setTimeout(() => {
                    // Force reload from server, not cache
                    window.location.href = window.location.href.split('#')[0];
                    window.location.reload(true);
                }, 1000);
                
            } catch (error) {
                // Re-enable input and button
                input.disabled = false;
                button.disabled = false;
                button.innerHTML = originalText;
                
                logToConsole(`Error handling property input: ${error.message}`, 'error');
                showError(`Failed to update property: ${error.message}`);
            }
        }

        // Remove duplicate handlers
        function handlePropertyUpdate(event, deviceId, property) {
            return handlePropertyInputKeydown(event);
        }

        // Update showToast to ensure it's visible
        function showToast(message, type = 'info') {
            // Remove any existing toasts
            const existingToasts = document.querySelectorAll('.toast-notification');
            existingToasts.forEach(toast => toast.remove());
            
            const toast = document.createElement('div');
            toast.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg text-white ${
                type === 'error' ? 'bg-red-500' : 
                type === 'success' ? 'bg-green-500' : 
                'bg-blue-500'
            } shadow-lg z-50 toast-notification`;
            
            toast.innerHTML = `
                <div class="flex items-center space-x-2">
                    ${type === 'success' ? `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                        </svg>
                    ` : type === 'error' ? `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    ` : `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                    `}
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Don't remove success toasts that indicate refresh
            if (!message.includes('Refreshing')) {
                setTimeout(() => toast.remove(), 3000);
            }
        }

        function showActiveDevices() {
            const devices = window.lastDevicesData || [];
            const modal = document.getElementById('active-devices-modal');
            const devicesList = document.getElementById('active-devices-list');

            devicesList.innerHTML = devices.map(device => {
                const statusEvent = device.events?.find(event => event.name === 'r_status');
                const isConnected = statusEvent?.value === 'CONNECTED';
                
                return `
                    <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg hover:bg-gray-100">
                        <div>
                            <h3 class="font-medium text-gray-800">${device.name || 'Unnamed Device'}</h3>
                            <p class="text-sm text-gray-500">
                                ID: ${device.id}
                            </p>
                        </div>
                        <span class="px-2 py-1 text-xs font-medium rounded-full ${isConnected ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-800'}">
                            ${isConnected ? 'Connected' : 'Disconnected'}
                        </span>
                    </div>
                `;
            }).join('') || '<p class="text-gray-500 text-center py-4">No active devices found</p>';

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideActiveDevices() {
            const modal = document.getElementById('active-devices-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        function showConnectedDevices() {
            const devices = window.lastDevicesData || [];
            const modal = document.getElementById('connected-devices-modal');
            const devicesList = document.getElementById('connected-devices-list');

            const connectedDevices = devices.filter(device => {
                const statusEvent = device.events?.find(event => event.name === 'r_status');
                return statusEvent?.value === 'CONNECTED';
            });

            devicesList.innerHTML = connectedDevices.length > 0 ? 
                connectedDevices.map(device => `
                    <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg hover:bg-gray-100">
                        <div>
                            <h3 class="font-medium text-gray-800">${device.name || 'Unnamed Device'}</h3>
                            <p class="text-sm text-gray-500">
                                ID: ${device.id}
                            </p>
                        </div>
                        <span class="px-2 py-1 text-xs font-medium rounded-full bg-green-100 text-green-800">
                            Connected
                        </span>
                </div>
                `).join('') 
                : '<p class="text-gray-500 text-center py-4">No connected devices found</p>';

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideConnectedDevices() {
            const modal = document.getElementById('connected-devices-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        function showGreatDevices() {
            const devices = window.lastDevicesData || [];
            const modal = document.getElementById('great-devices-modal');
            const devicesList = document.getElementById('great-devices-list');

            const greatDevices = devices.filter(device => calculateDeviceStatus(device).isGreat);

            devicesList.innerHTML = greatDevices.length > 0 ? 
                greatDevices.map(device => {
                    const status = calculateDeviceStatus(device);
                    return `
                        <div class="flex items-center justify-between p-3 bg-emerald-50 rounded-lg hover:bg-emerald-100">
                            <div>
                                <h3 class="font-medium text-emerald-800">${device.thing?.properties?.find(p => p.name === 'devicename')?.last_value || device.name || 'Unnamed Device'}</h3>
                                <p class="text-sm text-emerald-600">
                                    Cloud Temp: ${formatTemperature(status.cloudTemp, status.tempThresholdMax)} (Max: ${formatTemperature(status.tempThresholdMax)})<br>
                                    Time Since Flow: ${formatTimeDuration(status.timeSinceFlowMs)} (Critical: ${status.noFlowCriticalTime}h)
                                </p>
                            </div>
                            <span class="px-2 py-1 text-xs font-medium rounded-full bg-emerald-100 text-emerald-800">
                                Great
                            </span>
                        </div>
                    `;
                }).join('') 
                : '<p class="text-gray-500 text-center py-4">No devices in great condition found</p>';

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideGreatDevices() {
            const modal = document.getElementById('great-devices-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        function showWarningDevices() {
            const devices = window.lastDevicesData || [];
            const modal = document.getElementById('warning-devices-modal');
            const devicesList = document.getElementById('warning-devices-list');

            const warningDevices = devices.filter(device => calculateDeviceStatus(device).isWarning);

            devicesList.innerHTML = warningDevices.length > 0 ? 
                warningDevices.map(device => {
                    const status = calculateDeviceStatus(device);
                    return `
                        <div class="flex items-center justify-between p-3 bg-yellow-50 rounded-lg hover:bg-yellow-100">
                            <div>
                                <h3 class="font-medium text-yellow-800">${device.thing?.properties?.find(p => p.name === 'devicename')?.last_value || device.name || 'Unnamed Device'}</h3>
                                <p class="text-sm text-yellow-600">
                                    Cloud Temp: ${formatTemperature(status.cloudTemp)} (${status.cloudTemp > 32 ? 'High' : 'Normal'})<br>
                                    Time Since Flow: ${formatTimeDuration(status.timeSinceFlowMs)} (Critical: ${status.noFlowCriticalTime}h)
                                </p>
                            </div>
                            <span class="px-2 py-1 text-xs font-medium rounded-full bg-yellow-100 text-yellow-800">
                                Warning
                            </span>
                        </div>
                    `;
                }).join('') 
                : '<p class="text-gray-500 text-center py-4">No devices in warning state found</p>';

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideWarningDevices() {
            const modal = document.getElementById('warning-devices-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        function showCriticalDevices() {
            const devices = window.lastDevicesData || [];
            const modal = document.getElementById('critical-devices-modal');
            const devicesList = document.getElementById('critical-devices-list');

            const criticalDevices = devices.filter(device => calculateDeviceStatus(device).isCritical);

            devicesList.innerHTML = criticalDevices.length > 0 ? 
                criticalDevices.map(device => {
                    const status = calculateDeviceStatus(device);
                    return `
                        <div class="flex items-center justify-between p-3 bg-red-50 rounded-lg hover:bg-red-100">
                            <div>
                                <h3 class="font-medium text-red-800">${device.thing?.properties?.find(p => p.name === 'devicename')?.last_value || device.name || 'Unnamed Device'}</h3>
                                ${!status.isConnected ? `
                                    <p class="text-sm text-red-600">
                                        Disconnected since: ${new Date(status.lastConnectedTime).toLocaleString()}
                                    </p>
                                ` : `
                                    <p class="text-sm text-red-600">
                                        Cloud Temp: ${formatTemperature(status.cloudTemp)} (High)<br>
                                        Time Since Flow: ${formatTimeDuration(status.timeSinceFlowMs)} (Critical: ${status.noFlowCriticalTime}h)
                                    </p>
                                `}
                            </div>
                            <span class="px-2 py-1 text-xs font-medium rounded-full bg-red-100 text-red-800">
                                Critical
                            </span>
                        </div>
                    `;
                }).join('') 
                : '<p class="text-gray-500 text-center py-4">No devices in critical state found</p>';

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideCriticalDevices() {
            const modal = document.getElementById('critical-devices-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        function getSensorPlacementSelector(deviceId, property) {
            const currentValue = property.last_value ? property.last_value * 100 : null;
            return `
                <div class="flex flex-col space-y-2">
                    <div class="flex space-x-2">
                        <select 
                            class="w-full px-2 py-1 text-sm border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                            data-device-id="${deviceId}"
                            data-property='${JSON.stringify(property).replace(/'/g, "&apos;")}'
                            id="sensorPlacement_${deviceId}"
                        >
                            <option value="" ${!currentValue ? 'selected' : ''}>Select sensor placement</option>
                            <option value="0.10" ${currentValue === 10 ? 'selected' : ''}>10% from bottom</option>
                            <option value="0.25" ${currentValue === 25 ? 'selected' : ''}>25% from bottom</option>
                            <option value="0.50" ${currentValue === 50 ? 'selected' : ''}>50% from bottom</option>
                            <option value="0.75" ${currentValue === 75 ? 'selected' : ''}>75% from bottom</option>
                        </select>
                        <button 
                            onclick="handleUpdateButtonClick(event)"
                            data-device-id="${deviceId}"
                            data-property='${JSON.stringify(property).replace(/'/g, "&apos;")}'
                            class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 transition-colors"
                            type="button"
                        >
                            Update
                        </button>
                    </div>
                </div>
            `;
        }

        function handleSensorPlacementChange(select) {
            const deviceId = select.dataset.deviceId;
            const percentage = parseFloat(select.value);
            
            if (isNaN(percentage)) {
                logToConsole('Please select a valid sensor placement percentage', 'error');
                return;
            }
            
            try {
                const property = JSON.parse(select.dataset.property);
                const decimalValue = percentage / 100; // Convert percentage to decimal
                
                if (!deviceId) {
                    throw new Error('Device ID is missing');
                }

                // Log the update attempt
                logToConsole(`Updating sensor placement for device ${deviceId} to ${percentage}% (${decimalValue})`);

                // Use the same API endpoint and structure that works for other variables
                const apiUrl = `${API_URL}/api/iot/v2/devices/${deviceId}/properties`;
                
                fetch(apiUrl, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        propertiesValues: {
                            input: true,
                            properties: [{
                                name: 'sensorplacement',
                                type: 'FLOAT',
                                value: decimalValue
                            }]
                        }
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    logToConsole(`Successfully updated sensor placement to ${percentage}%`);
                    // Refresh devices to show updated value
                    fetchDevices();
                })
                .catch(error => {
                    logToConsole(`Error updating sensor placement: ${error.message}`, 'error');
                    showError(`Failed to update sensor placement: ${error.message}`);
                });
            } catch (error) {
                logToConsole(`Error handling sensor placement: ${error.message}`, 'error');
                showError(`Failed to handle sensor placement: ${error.message}`);
            }
        }

        function handleManualStatusUpdate(deviceId, statusType, value) {
            // Check cooldown before updating
            if (!canUpdateStatus(deviceId, statusType)) {
                logToConsole(`Skipping ${statusType} update for device ${deviceId} - cooldown period not elapsed`);
                return;
            }

            try {
                logToConsole(`Attempting to update ${statusType} to ${value} for device ${deviceId}`);

                const apiUrl = `${API_URL}/api/iot/v2/devices/${deviceId}/properties`;
                
                fetch(apiUrl, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        propertiesValues: {
                            input: true,
                            properties: [{
                                name: statusType,
                                type: 'STATUS',
                                value: value
                            }]
                        }
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    updateLastStatusTime(deviceId, statusType);
                    logToConsole(`Successfully updated ${statusType} to ${value}`);
                    // Refresh devices to show updated value after a short delay
                    setTimeout(fetchDevices, 1000);
                })
                .catch(error => {
                    logToConsole(`Error updating ${statusType}: ${error.message}`, 'error');
                    showError(`Failed to update ${statusType}: ${error.message}`);
                });
            } catch (error) {
                logToConsole(`Error handling ${statusType} update: ${error.message}`, 'error');
                showError(`Failed to handle ${statusType} update: ${error.message}`);
            }
        }

        function getStatusControls(deviceId, properties) {
            // Keep the status calculation logic for internal use
            const warningProp = properties.find(p => p.name === 'warning');
            const criticalProp = properties.find(p => p.name === 'critical');
            
            // Convert string values to boolean for comparison
            const warningValue = warningProp?.last_value === true || warningProp?.last_value === 'true';
            const criticalValue = criticalProp?.last_value === true || criticalProp?.last_value === 'true';

            // Get calculated status
            const device = window.lastDevicesData.find(d => d.id === deviceId);
            const calculatedStatus = calculateDeviceStatus(device);

            // Determine status states (keep this for internal use)
            const shouldBeWarning = calculatedStatus.isWarning;
            const shouldBeCritical = calculatedStatus.isCritical;

            // Return empty string to hide the section from view
            return '';
        }


        // Add refresh button to manually trigger data refresh
        function addRefreshButton() {
            const refreshButton = document.createElement('button');
            refreshButton.innerHTML = `
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                    </svg>
                    Refresh Data
                </span>
            `;
            refreshButton.className = 'bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded flex items-center gap-2 mb-4';
            refreshButton.onclick = function() {
                // Clear the cache
                timeSeriesDataCache.clear();
                // Reload the page
                window.location.reload();
            };

            // Add the button at the top of the page
            const container = document.querySelector('#devices');
            container.parentNode.insertBefore(refreshButton, container);
        }



        function showDisclaimer() {
            const modal = document.getElementById('disclaimer-modal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideDisclaimer() {
            const modal = document.getElementById('disclaimer-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        function showContactModal() {
            const modal = document.getElementById('contact-modal');
            if (modal) {
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.body.style.overflow = 'hidden';
                console.log('Contact modal opened');
            } else {
                console.error('Contact modal element not found');
            }
        }

        function hideContact() {
            const modal = document.getElementById('contact-modal');
            if (modal) {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                document.body.style.overflow = 'auto';
                console.log('Contact modal closed');
            } else {
                console.error('Contact modal element not found');
            }
        }

        function showFAQ() {
            const modal = document.getElementById('faq-modal');
            if (modal) {
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                document.body.style.overflow = 'hidden';
            } else {
                console.error('FAQ modal element not found');
                
                // Debug info to help locate the issue
                console.log('Modals container contents:', document.getElementById('modals')?.innerHTML);
                console.log('All available modals:', {
                    'faq-modal': document.getElementById('faq-modal'),
                    'disclaimer-modal': document.getElementById('disclaimer-modal'),
                    'contact-modal': document.getElementById('contact-modal'),
                    'setup-modal': document.getElementById('setup-modal'),
                    'known-bugs-modal': document.getElementById('known-bugs-modal')
                });
                
                // Try to re-inject the FAQ modal
                fetch('./components/modals.html')
                    .then(response => response.text())
                    .then(html => {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = html;
                        const faqModal = tempDiv.querySelector('#faq-modal');
                        
                        if (faqModal) {
                            if (!document.getElementById('modals')) {
                                const modalsDiv = document.createElement('div');
                                modalsDiv.id = 'modals';
                                document.body.appendChild(modalsDiv);
                            }
                            
                            document.getElementById('modals').appendChild(faqModal);
                            console.log('Successfully injected faq-modal');
                            
                            // Now show it
                            faqModal.classList.remove('hidden');
                            faqModal.classList.add('flex');
                            document.body.style.overflow = 'hidden';
                        } else {
                            showError('Could not find FAQ modal content. Please refresh the page.');
                        }
                    })
                    .catch(err => {
                        console.error('Failed to load FAQ modal:', err);
                        showError('Failed to load FAQ modal. Please refresh the page.');
                    });
            }
        }

        function closeFAQ() {
            const modal = document.getElementById('faq-modal');
            if (modal) {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                document.body.style.overflow = 'auto';
            } else {
                console.error('FAQ modal element not found when trying to close it');
            }
        }

        // Add to script section
        async function saveNotificationSettings(deviceId) {
            const email = document.getElementById('notification-email').value;
            const enabled = document.getElementById('enable-notifications').checked;

            try {
                const response = await fetch(`${API_URL}/api/notifications/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ deviceId, email, enabled })
                });

                if (!response.ok) throw new Error('Failed to save settings');
                
                showToast('Notification settings saved successfully', 'success');
            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        function validateEmail(email) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
        }

        function showToast(message, type) {
            const toast = document.createElement('div');
            toast.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg text-white ${
                type === 'error' ? 'bg-red-500' : 'bg-green-500'
            }`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.remove(), 3000);
        }

        async function handleUpdate(event, deviceId, property) {
            event.preventDefault();
            await updatePropertyValue(deviceId, property);
        }

        
        async function updatePropertyValue(deviceId, property) {
            try {
                if (!deviceId || !property) {
                    throw new Error('Device ID and Property are required');
                }

                // Log the update attempt with all details
                logToConsole({
                    message: 'Attempting to update property',
                    deviceId: deviceId,
                    propertyName: property.name,
                    currentValue: property.last_value,
                    newValue: property.new_value,
                    propertyType: property.type
                }, 'info');

                // Format the value based on type
                let formattedValue;
                switch(property.type) {
                    case 'INT':
                        formattedValue = parseInt(property.new_value);
                        if (isNaN(formattedValue)) {
                            throw new Error('Invalid integer value');
                        }
                        break;
                    case 'FLOAT':
                        // Convert Fahrenheit to Celsius if this is a temperature property
                        if (property.name.toLowerCase().includes('temp')) {
                            formattedValue = fahrenheitToCelsius(parseFloat(property.new_value));
                        } else {
                            formattedValue = parseFloat(property.new_value);
                        }
                        if (isNaN(formattedValue)) {
                            throw new Error('Invalid float value');
                        }
                        break;
                    case 'BOOL':
                        // Convert to actual boolean instead of string
                        formattedValue = property.new_value === true || property.new_value === 'true';
                        break;
                    case 'CHARSTRING':
                    case 'STATUS':
                        formattedValue = String(property.new_value).trim();
                        if (!formattedValue) {
                            throw new Error('Value cannot be empty');
                        }
                        break;
                    default:
                        formattedValue = property.new_value;
                }

                // Using V2 API endpoint format and structure
                const apiUrl = `${API_URL}/api/iot/v2/devices/${deviceId}/properties`;

                // Construct payload exactly as per Arduino V2 API docs
                const requestBody = {
                    propertiesValues: {
                        input: true,
                        properties: [{
                            name: property.name,
                            type: property.type,
                            value: formattedValue // Send raw value without converting to string
                        }]
                    }
                };

                logToConsole({
                    message: 'Sending update request',
                    url: apiUrl,
                    body: requestBody
                }, 'info');

                const response = await fetch(apiUrl, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'X-Organization': property.organization_id || ''  // Add organization ID if available
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    throw new Error(errorData?.error || `HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                logToConsole({
                    message: 'Update successful',
                    deviceId: deviceId,
                    propertyName: property.name,
                    response: result
                }, 'info');

                // Refresh the devices list to show the new value
                await fetchDevices();
                setTimeout(() => {
                    location.reload(true);
                }, 3000); // Wait 3 seconds before reloading
                
            } catch (error) {
                logToConsole({
                    message: 'Error updating property',
                    error: error.message,
                    deviceId: deviceId,
                    propertyName: property?.name
                }, 'error');
                showError(`Failed to update property: ${error.message}`);
            }
        }

      
        // Add keyboard shortcut for manual commit
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + Shift + C to trigger manual commit
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
                autoCommitChanges();
            }
        });

        // Add these functions to the script section
        function showDeviceSettings(deviceId) {
            const device = window.lastDevicesData.find(d => d.id === deviceId);
            if (!device) {
                console.error('Device not found:', deviceId);
                return;
            }

            const modalContent = document.getElementById('settings-modal-content');
            const modalTitle = document.getElementById('settings-modal-title');
            const modal = document.getElementById('settings-modal');
            const status = calculateDeviceStatus(device);
            
            modalTitle.textContent = `Settings - ${device.thing?.properties?.find(p => p.name === 'devicename')?.last_value || device.name}`;
            
            // Create settings content with sections in new order: Recommendations, Properties, and Device Information at the bottom
            modalContent.innerHTML = `
                <div class="space-y-6">
                    <!-- Recommendations Section -->
                    ${generateRecommendationsHTML(status, device)}

                    <!-- Properties Section -->
                    ${renderPropertiesSection(device)}

                    <!-- Device Information Section -->
                    ${renderDeviceInformation(device, status)}
                </div>
            `;
            
            modal.classList.remove('hidden');
            modal.classList.add('flex');

            // Add click event listener to close modal when clicking outside
            modal.addEventListener('click', function(event) {
                // Check if the click was on the modal background (not the content)
                if (event.target === modal) {
                    hideDeviceSettings();
                }
            });
        }

        function hideDeviceSettings() {
            const modal = document.getElementById('settings-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        // Helper function to convert Celsius to Fahrenheit
        function celsiusToFahrenheit(celsius) {
            if (celsius === undefined || celsius === null || isNaN(celsius)) {
                return NaN; // Return NaN for invalid input
            }
            return (celsius * 9/5) + 32;
        }

        function fahrenheitToCelsius(fahrenheit) {
            return (fahrenheit - 32) * 5/9;
        }

        function showAllDevices() {
            const devices = window.lastDevicesData || [];
            const modal = document.getElementById('connected-devices-modal');
            const devicesList = document.getElementById('connected-devices-list');

            // Sort devices: disconnected first, then by name
            const sortedDevices = [...devices].sort((a, b) => {
                const aStatus = calculateDeviceStatus(a);
                const bStatus = calculateDeviceStatus(b);
                
                // First sort by connection status (disconnected first)
                if (!aStatus.isConnected && bStatus.isConnected) return -1;
                if (aStatus.isConnected && !bStatus.isConnected) return 1;
                
                // Then sort by device name
                const aName = a.thing?.properties?.find(p => p.name === 'devicename')?.last_value || a.name;
                const bName = b.thing?.properties?.find(p => p.name === 'devicename')?.last_value || b.name;
                return aName.localeCompare(bName);
            });

            devicesList.innerHTML = sortedDevices.length > 0 ? 
                sortedDevices.map(device => {
                    const status = calculateDeviceStatus(device);
                    const deviceName = device.thing?.properties?.find(p => p.name === 'devicename')?.last_value || device.name || 'Unnamed Device';
                    const location = device.thing?.properties?.find(p => p.name === 'location')?.last_value || 'Location not set';
                    
                    return `
                        <div class="flex items-center justify-between p-3 ${status.isConnected ? 'bg-gray-50 hover:bg-gray-100' : 'bg-red-50 hover:bg-red-100'} rounded-lg">
                            <div>
                                <h3 class="font-medium ${status.isConnected ? 'text-gray-800' : 'text-red-800'}">${deviceName}</h3>
                                <p class="text-sm ${status.isConnected ? 'text-gray-500' : 'text-red-600'}">
                                    ${location}
                                    ${!status.isConnected ? `<br>Last seen: ${new Date(status.lastConnectedTime).toLocaleString()}` : ''}
                                </p>
                            </div>
                            <span class="px-2 py-1 text-xs font-medium rounded-full ${status.isConnected ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                ${status.isConnected ? 'Connected' : 'Disconnected'}
                            </span>
                        </div>
                    `;
                }).join('') 
                : '<p class="text-gray-500 text-center py-4">No devices found</p>';

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

    </script>
</body>
</html>

